P1: Longest Increasing Subsequence Size
令arr[0...n-1]是输入数组，L(i)是以arr[i]为结尾的子串中的LIS长度。那么我们可以总结出以下的规律：

if (0<j<i && arr[j]<arr[i]) L(i)=1+max(L(j))

else L(i)=1;

该解法的时间复杂度为O(n^2)，我们接下来会介绍时间复杂度为O(n log n)
　　让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。

　　前1个数 d(1)=1 子序列为2；

　　前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7

　　前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1

　　前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5

　　前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6

　　前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4

　　前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3

　　前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8

　　前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9

　　d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5
　总结一下，d(i)就是找以A[i]结尾的，在A[i]之前的最长上升子序列+1，当A[i]之前没有比A[i]更小的数时，d(i)=1。所有的d(i)里面最大的那个就是最长上升子序列。其实说的通俗点，就是每次都向前找比它小的数和比它大的数的位置，将第一个比它大的替换掉，这样操作虽然LIS序列的具体数字可能会变，但是很明显LIS长度还是不变的，因为只是把数替换掉了，并没有改变增加或者减少长度。但是我们通过这种方式是无法求出最长上升子序列具体是什么的，这点和最长公共子序列不同。
--------------------- 
作者：lxt_Lucia 
来源：CSDN 
原文：https://blog.csdn.net/lxt_Lucia/article/details/81206439 
版权声明：本文为博主原创文章，转载请附上博文链接！
--------------------- 
作者：lxt_Lucia 
来源：CSDN 
原文：https://blog.csdn.net/lxt_Lucia/article/details/81206439 
版权声明：本文为博主原创文章，转载请附上博文链接！
--------------------- 
作者：Britjeans 
来源：CSDN 
原文：https://blog.csdn.net/weixin_30104533/article/details/81011945 
版权声明：本文为博主原创文章，转载请附上博文链接！
