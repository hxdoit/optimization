P1: Longest Increasing Subsequence Size
令arr[0...n-1]是输入数组，L(i)是以arr[i]为结尾的子串中的LIS长度。那么我们可以总结出以下的规律：

if (0<j<i && arr[j]<arr[i]) L(i)=1+max(L(j))

else L(i)=1;

该解法的时间复杂度为O(n^2)，我们接下来会介绍时间复杂度为O(n log n)
　　让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。

　　前1个数 d(1)=1 子序列为2；

　　前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7

　　前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1

　　前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5

　　前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6

　　前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4

　　前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3

　　前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8

　　前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9

　　d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5
　总结一下，d(i)就是找以A[i]结尾的，在A[i]之前的最长上升子序列+1，当A[i]之前没有比A[i]更小的数时，d(i)=1。所有的d(i)里面最大的那个就是最长上升子序列。其实说的通俗点，就是每次都向前找比它小的数和比它大的数的位置，将第一个比它大的替换掉，这样操作虽然LIS序列的具体数字可能会变，但是很明显LIS长度还是不变的，因为只是把数替换掉了，并没有改变增加或者减少长度。但是我们通过这种方式是无法求出最长上升子序列具体是什么的，这点和最长公共子序列不同。
--------------------- 
作者：lxt_Lucia 
来源：CSDN 
原文：https://blog.csdn.net/lxt_Lucia/article/details/81206439 
版权声明：本文为博主原创文章，转载请附上博文链接！
--------------------- 
作者：lxt_Lucia 
来源：CSDN 
原文：https://blog.csdn.net/lxt_Lucia/article/details/81206439 
版权声明：本文为博主原创文章，转载请附上博文链接！
--------------------- 
作者：Britjeans 
来源：CSDN 
原文：https://blog.csdn.net/weixin_30104533/article/details/81011945 
版权声明：本文为博主原创文章，转载请附上博文链接！

http://www.elecfans.com/dianzichangshi/20171130589302.html
一、动态规划算法简介
　　动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。

　　1.基本思想与策略
　　动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

动态规划算法和贪心算法的区别与联系

　　2.适用情况
　　能采用动态规划求解的问题的一般要具有3个性质：

　　（1）最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

　　（2）无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

　　（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

　　3.算法实现
　　动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：

　　（1）问题的阶段

　　（2）每个阶段的状态

　　（3）从前一个阶段转化到后一个阶段之间的递推关系。

　　递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。

　　确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

动态规划算法和贪心算法的区别与联系

　　二、贪心算法简介
　　贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

　　1.基本要素
　　贪心选择

　　贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择的性质，我们必须证明每一步所作的贪心选择最终能得到问题的最优解。通常可以首先证明问题的一个整体最优解，是从贪心选择开始的，而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。

　　最优子结构

　　当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题。

动态规划算法和贪心算法的区别与联系

　　2.算法特性
　　贪婪算法可解决的问题通常大部分都有如下的特性：

　　随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。

　　有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。

　　还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。

　　选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。

　　最后，目标函数给出解的值。

　　为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。

动态规划算法和贪心算法的区别与联系

　　三、动态规划算法和贪心算法的区别与联系
　　背景介绍：这两种算法都是选择性算法，就是从一个候选集合中选择适当的元素加入解集合。

　　贪心算法的选择策略即贪心选择策略，通过对候选解按照一定的规则进行排序，然后就可以按照这个排好的顺序进行选择了，选择过程中仅需确定当前元素是否要选取，与后面的元素是什么没有关系。

　　动态规划的选择策略是试探性的，每一步要试探所有的可行解并将结果保存起来，最后通过回溯的方法确定最优解，其试探策略称为决策过程。

　　主要不同：两种算法的应用背景很相近，针对具体问题，有两个性质是与算法选择直接相关的，最优子结构性质和贪心选择性质。

　　最优子结构性质是选择类最优解都具有的性质，即全优一定包含局优，上一次选择最短路线的例子已经对此作了说。

　　当时我们也提到了贪心选择性质，满足贪心选择性质的问题可用贪心算法解决，不满足贪心选择性质的问题只能用动态规划解决。可见能用贪心算法解决的问题理论上都可以利用动态规划解决，而一旦证明贪心选择性质，用贪心算法解决问题比动态规划具有更低的时间复杂度和空间复杂度。

　　贪心算法：

　　1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。

　　2.贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。

　　动态规划算法：

　　1.全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解

　　2.动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解

　　3.边界条件：即最简单的，可以直接得出的局部最优解

　　所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是利用贪心算法求解最优解的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

　　在贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。并且，每一步的最优解一定包含上一步的最优解。

　　而在动态规划算法中，全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解。也就是说，把一个复杂问题分解成一块一块的小问题，每一个问题得到最优解，再从这些最优解中获取更优的答案。
